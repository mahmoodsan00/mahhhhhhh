# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t1J-sJSrDC2CMhDI_kZiUGlrrvsuTZLV

1. Required Libraries
"""

# Import all the necessary libraries
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.ticker as mticker

from sklearn.model_selection import train_test_split

from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler

from sklearn.linear_model import LinearRegression


from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

"""2. Load Data"""

import pandas as pd


heartData = pd.read_csv("/content/heart-failure-prediction/heart.csv")

# Check the first few rows of the dataset
print(heartData.head())

"""3. Data Analysis"""

#use .info(), .head(), .tail(), .describe(), .shape for data analysis
print(f'{heartData.info()}\n\n')
print(f'{heartData.head()}\n\n')
print(f'{heartData.tail()}\n\n')
print(f'{heartData.describe()}\n\n')
print(f'{heartData.shape}')

"""4. Data Visualisation using MatPlotLib"""

# Using a heatmap to display the age range and gender
ageRange = pd.cut(heartData['Age'], bins = [20, 30, 40, 50, 60, 70, 80])
heatmap = heartData.pivot_table(index = ageRange, columns = 'Sex', values = 'Age')


plt.figure(figsize = (10, 6))
sns.heatmap(heatmap, annot = True, cbar_kws = {'label' : 'Count of Entries'})
plt.title('Heat Map visualising the Age and Gender of people experiencing Chest Pain')
plt.xlabel('Gender')
plt.ylabel('Age Range')
plt.show()

# Using a bar graph to display the type of chest pain experienced by the population
sns.countplot(x = 'ChestPainType', data = heartData, palette = 'crest')
plt.title('Bar Graph showing the different types of Chest Pain experienced by population')
plt.xlabel('Type of Chest Pain')
plt.ylabel('Number of People Experiencing Pain')
plt.show()

"""5. Split Data into Training and Testing"""

# Converting needed data into useable values
# Label encoding allows non-numerical / categorical data to become numerical
Label_Encoder = LabelEncoder()

heartData["Sex"] = Label_Encoder.fit_transform(heartData["Sex"])
heartData["ChestPainType"] = Label_Encoder.fit_transform(heartData["ChestPainType"])
heartData["RestingECG"] = Label_Encoder.fit_transform(heartData["RestingECG"])
heartData["ExerciseAngina"] = Label_Encoder.fit_transform(heartData["ExerciseAngina"])
heartData["ST_Slope"] = Label_Encoder.fit_transform(heartData["ST_Slope"])

# Removing "Cholesterol" from the x column and moving it into y
x = heartData.drop(["Cholesterol"], axis = 1)
y = heartData["Cholesterol"]


# This is to check if ChestPainType has been properly converted and to check for NaN values
print(x.dtypes)
print(x.isnull().sum())

# Since in all data there are ouliers, I used StandardScaler to essentially round them off to make the prediction more accurate
Standard_Scaler = StandardScaler()
x = Standard_Scaler.fit_transform(x)

# Splitting data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 42)

"""6. Build Model / Model Training"""

# Initialize LinearRegression algorithm
LinearReg = LinearRegression()
LinearReg.fit(x_train, y_train)

# Using .predict() to give predictions based on the testing data
y_pred = LinearReg.predict(x_test)
print(y_pred)

"""7. Model Evaluation"""

# Using MSE and R2 to know the accuracy of the model
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)

# These indicate that the error margin for the model are fairly low and that it's pretty accurate
print(f'Mean Squared Error: {mse}')
print(f'R2 Score: {r2}')

plt.figure(figsize = (10, 6))
sns.scatterplot(x = y_test.values.ravel(), y = y_pred.ravel(), alpha = 0.7, color = 'blue', edgecolor = 'k')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')
plt.xlabel('Cholesterol Level')
plt.ylabel('Experienced Chest Pain')
plt.title('Correlation between cholesterol level and experienced chest pain')
plt.show()